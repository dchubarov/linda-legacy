
/*
 * TWOWLS.ORG PROPRIETARY/CONFIDENTIAL
 *
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package org.twowls.lab.legacy.linde.producer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 *
 * @author da
 */
public class Producer {

    private static final char ZERO = (char) 0;

    private boolean ignoreCase = false;
    private List<Interpreter> interpreters = null;
    private Map<Character, Rule> rules = null;
    private String axiom = null;

    /**
     * Creates a new instance of {@link Producer}.
     * The new instance will be case-sensitive.
     */
    public Producer() {
        this(false);
    }

    /**
     * Creates a new instance of {@link Producer}.
     * @param ignoreCase indicates whether producer
     *  ignores case of characters or not.
     */
    public Producer(boolean ignoreCase) {
        this.ignoreCase = ignoreCase;
    }

    /**
     * Adds a new {@link Interpreter} to the current producer.
     * An interpreter is an object which processes data
     * generated by producer.
     * @param interp an {@link Interpreter} instance to add.
     * @throws IllegalArgumentException if argument {@code interp} is null
     */
    public void addInterpreter(Interpreter interp) {
        if (interp == null) {
            throw new IllegalArgumentException("addInterpreter(): " +
                    "Argument interp is null");
        }

        if (interpreters == null) {
            interpreters = new ArrayList<>();
        }
        else {
            if (interpreters.contains(interp)) {
                return;
            }
        }

        interpreters.add(interp);
    }

    /**
     * Removes the specified interpreter from the current producer.
     * If the given interpreter has not been added nothing will happen.
     * @param interp an {@link Interpreter} instance to remove
     */
    public void removeInterpreter(Interpreter interp) {
        if (interpreters != null) {
            if (interp != null && interpreters.contains(interp)) {
                interpreters.remove(interp);
            }
        }
    }

    public static boolean isInvalidSymbol(char symbol) {
        return (symbol < 33);
    }

    public void addRule(char symbol, String expression)
            throws ProducerException {
        addRule(symbol, expression, ZERO);
    }

    public void addRule(char symbol, String expression, char mean)
            throws ProducerException {

        symbol = ignoreCase ? Character.toUpperCase(symbol) : symbol;
        if (isInvalidSymbol(symbol)) {
            throw new ProducerException("Invalid symbol: '" + symbol + "'");
        }

        if (mean != ZERO) {
            mean = ignoreCase ? Character.toUpperCase(mean) : mean;
            if (isInvalidSymbol(mean)) {
                throw new ProducerException("Invalid mean: '" + mean + "'");
            }
        }

        addRule(symbol, new Rule(expression.trim(), mean));
    }

    public void addRule(char symbol, Rule rule) {
        if (rule == null) {
            throw new IllegalArgumentException("");
        }

        if (rules == null) {
            rules = new HashMap<>();
        }

        rules.put(symbol, rule);
    }

    private Rule getRuleFor(char symbol) {
        if (rules != null) {
            symbol = ignoreCase ? Character.toUpperCase(symbol) : symbol;
            if (rules.containsKey(symbol)) {
                return rules.get(symbol);
            }
        }
        return null;
    }

    public String getAxiom() {
        return axiom;
    }

    public void setAxiom(String axiom) {
        this.axiom = axiom.trim();
    }

    public void produce(int order) throws ProducerException {
        // Order must be positive or zero
        if (order < 0) {
            throw new IllegalArgumentException("produce(): " +
                    "Argument order must be positive or zero.");
        }

        // Check if axiom is empty
        if (axiom == null || axiom.isEmpty()) {
            throw new ProducerException("Axiom is empty.");
        }

        // There must be interpreters, no sense to produce otherwise
        if (interpreters.size() > 0) {

            // Initialize parse context
            int currentOrder = order;
            LinkedList<RuleParser> stack = new LinkedList<>();
            RuleParser top = new RuleParser(new Rule(getAxiom()));
            stack.push(top);

            // Is there only one interpreter? (optimization)
            Interpreter onlyInterp = (interpreters.size() == 1)
                    ? interpreters.get(0) : null;

            if (onlyInterp != null) {
                onlyInterp.start(order);
            }
            else {
                final int o1 = order;
                doAllInterpreters(interp -> interp.start(o1));
            }

            boolean done = false;
            do {
                char c = top.getNextChar();

                if (c == ZERO) {
                    if (currentOrder < order) {
                        stack.pop();
                        top = stack.peek();
                        currentOrder++;

                        if (onlyInterp != null) {
                            onlyInterp.ascend(currentOrder);
                        }
                        else {
                            final int o1 = currentOrder;
                            doAllInterpreters(interp -> interp.ascend(o1));
                        }
                    }
                    else {
                        done = true;
                    }
                }
                else {
                    if (ignoreCase) {
                        c = Character.toUpperCase(c);
                    }

                    Rule rule = getRuleFor(c);
                    if (rule != null) {
                        if (currentOrder > 0 && !rule.isEmpty()) {
                            top = new RuleParser(rule);
                            stack.push(top);
                            currentOrder--;

                            if (onlyInterp != null) {
                                onlyInterp.descend(currentOrder);
                            }
                            else {
                                final int o1 = currentOrder;
                                doAllInterpreters(interp -> interp.descend(o1));
                            }

                            continue;
                        }

                        // Replace with mean(ing) if any
                        char mean = rule.getMean();
                        if (mean != ZERO) {
                            c = mean;
                        }
                    }

                    // Interpret current character
                    if (onlyInterp != null) {
                        onlyInterp.interpret(c);
                    }
                    else {
                        final char c1 = c;
                        doAllInterpreters(interp -> interp.interpret(c1));
                    }
                }
            } while (!done);
        }
    }

    private void doAllInterpreters(InterpreterAction action)
            throws ProducerException {
        if (interpreters != null) {
            for (Interpreter interpreter : interpreters) {
                action.perform(interpreter);
            }
        }
    }

    private interface InterpreterAction {
        void perform(Interpreter interp) throws ProducerException;
    }

    public static class Rule {
        private String expression = null;
        private char mean = ZERO;

        public Rule(String expression, char mean) {
            this.expression = expression;
            this.mean = mean;
        }

        public Rule(String expression) {
            this(expression, ZERO);
        }

        public String getExpression() {
            return expression;
        }

        public char getMean() {
            return mean;
        }

        public boolean isEmpty() {
            return (expression == null || expression.isEmpty());
        }
    }

    private static class RuleParser {
        private Rule rule = null;
        private int index = 0;

        public RuleParser(Rule rule) {
            this.rule = rule;
        }

        public char getNextChar() {
            char c = ZERO;
            if (rule != null && !rule.isEmpty()) {
                for (String e = rule.getExpression(); c == ZERO
                        && index < e.length(); index++) {
                    c = e.charAt(index);
                    if (Character.isWhitespace(c)) {
                        c = ZERO;
                    }
                }
            }

            return c;
        }
    }
}
